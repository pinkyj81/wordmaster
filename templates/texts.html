{% extends "base.html" %}
{% block content %}
<div class="p-8">
  <h2 class="text-2xl font-bold mb-6 text-gray-800">텍스트 관리</h2>

  <!-- ✅ 텍스트 목록 -->
  <div id="textList" class="space-y-4">
    {% for t in texts %}
    <div class="flex justify-between items-center bg-white shadow rounded-xl p-4 hover:shadow-md transition">
      <div>
        <p class="font-semibold text-lg text-gray-800">{{ t.title }}</p>
        <p class="text-sm text-gray-500">저장된 단어: {{ t.word_count }}개 · 출처: {{ t.source or '미지정' }}</p>
      </div>
      <div class="flex gap-2">
        <button onclick="openTextModal('{{ t.id }}', '{{ t.title }}', `{{ t.content|escapejs }}`)"
                class="px-3 py-1 bg-yellow-500 text-white rounded hover:bg-yellow-600 text-sm">
          텍스트 수정
        </button>
        <button onclick="openWordModal('{{ t.id }}')"
                class="px-3 py-1 bg-indigo-500 text-white rounded hover:bg-indigo-600 text-sm">
          단어 수정
        </button>
        <a href="/flashcards/{{ t.id }}"
           class="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm">
          읽기
        </a>
      </div>
    </div>
    {% endfor %}
  </div>
</div>


<!-- ✅ 텍스트 수정 모달 -->
<div id="textModal" class="fixed inset-0 bg-black/50 hidden items-center justify-center z-50">
  <div class="bg-white rounded-xl w-[600px] p-6 shadow-lg">
    <h3 class="text-lg font-semibold text-gray-800 mb-4">텍스트 수정</h3>
    <input type="hidden" id="editTextId">
    <label class="block mb-2 text-gray-600 text-sm">제목</label>
    <input id="editTextTitle" class="w-full border rounded-lg p-2 mb-4" />

    <label class="block mb-2 text-gray-600 text-sm">본문</label>
    <textarea id="editTextContent" class="w-full border rounded-lg p-2 h-40 mb-6"></textarea>

    <div class="flex justify-end space-x-2">
      <button onclick="closeTextModal()" class="px-4 py-2 bg-gray-300 rounded hover:bg-gray-400">취소</button>
      <button onclick="saveTextEdit()" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">저장</button>
    </div>
  </div>
</div>


<!-- ✅ 단어 수정 모달 -->
<div id="wordModal" class="fixed inset-0 bg-black/50 hidden items-center justify-center z-50">
  <div class="bg-white rounded-xl w-[700px] p-6 shadow-lg">
    <h3 class="text-lg font-semibold text-gray-800 mb-4">단어 수정</h3>
    <div id="wordEditList" class="space-y-2 max-h-[300px] overflow-y-auto mb-6"></div>

    <div class="flex justify-end space-x-2">
      <button onclick="closeWordModal()" class="px-4 py-2 bg-gray-300 rounded hover:bg-gray-400">닫기</button>
      <button onclick="saveWordEdits()" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">저장</button>
    </div>
  </div>
</div>

<script>
// ✅ 텍스트 수정 모달 열기
function openTextModal(id, title, content) {
  document.getElementById('editTextId').value = id;
  document.getElementById('editTextTitle').value = title;
  document.getElementById('editTextContent').value = content;
  document.getElementById('textModal').classList.remove('hidden');
  document.getElementById('textModal').classList.add('flex');
}

// ✅ 텍스트 수정 닫기
function closeTextModal() {
  document.getElementById('textModal').classList.add('hidden');
}

// ✅ 텍스트 저장
function saveTextEdit() {
  const id = document.getElementById('editTextId').value;
  const title = document.getElementById('editTextTitle').value;
  const content = document.getElementById('editTextContent').value;

  fetch('/update_text', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ id, title, content })
  })
  .then(res => res.json())
  .then(data => {
    alert('✅ 텍스트 수정 완료');
    location.reload();
  })
  .catch(err => alert('❌ 수정 중 오류 발생'));
}

// ✅ 단어 수정 모달 열기
function openWordModal(textId) {
  fetch(`/get_words/${textId}`)
    .then(res => res.json())
    .then(data => {
      const container = document.getElementById('wordEditList');
      container.innerHTML = "";
      data.forEach(w => {
        container.innerHTML += `
          <div class="flex items-center space-x-2">
            <input value="${w.word}" data-id="${w.id}" class="border rounded p-1 w-1/3 word-input">
            <input value="${w.meaning}" class="border rounded p-1 w-2/3 meaning-input">
          </div>`;
      });
      document.getElementById('wordModal').dataset.textId = textId;
      document.getElementById('wordModal').classList.remove('hidden');
      document.getElementById('wordModal').classList.add('flex');
    });
}

// ✅ 단어 수정 저장
function saveWordEdits() {
  const textId = document.getElementById('wordModal').dataset.textId;
  const words = Array.from(document.querySelectorAll('.word-input')).map((input, i) => ({
    id: input.dataset.id,
    word: input.value,
    meaning: document.querySelectorAll('.meaning-input')[i].value
  }));

  fetch('/update_words', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text_id: textId, words })
  })
  .then(res => res.json())
  .then(data => {
    alert('✅ 단어 수정 완료');
    closeWordModal();
  })
  .catch(err => alert('❌ 수정 중 오류 발생'));
}

// ✅ 단어 모달 닫기
function closeWordModal() {
  document.getElementById('wordModal').classList.add('hidden');
}
</script>
{% endblock %}
