{% extends "base.html" %}
{% block content %}

<h2 class="text-2xl font-semibold mb-6 text-gray-800">í…ìŠ¤íŠ¸ ê¸°ë¡</h2>

<!-- ìƒë‹¨ í•„í„°/ê²€ìƒ‰ + ì—…ë¡œë“œ ë²„íŠ¼ -->
<div class="flex flex-wrap items-center justify-between mb-6 space-y-2 sm:space-y-0">
  <div class="flex items-center space-x-2">
   <select id="sourceFilter" class="border rounded px-2 py-1">
  <option value="">ëª¨ë“  ì¶œì²˜</option>
  {% for src in sources %}
    <option value="{{ src }}">{{ src }}</option>
  {% endfor %}
</select>

    <select class="border rounded-md px-2 py-1 text-sm">
      <option>ì œëª©ìˆœ</option>
      <option>ìµœê·¼ìˆœ</option>
    </select>
  </div>

  <div class="flex items-center space-x-2">
    <input type="text" placeholder="ì œëª©, ë‚´ìš©, ì¶œì²˜ ê²€ìƒ‰..."
           class="border px-3 py-1 rounded-md w-64 text-sm focus:outline-none focus:ring-1 focus:ring-blue-400">
    <button type="button" id="openUnknownTestBtn" onclick="openUnknownTestModal()"
            class="bg-green-500 text-white px-3 py-1 rounded hover:bg-green-600 transition">
      ëª¨ë¥´ëŠ” ë‹¨ì–´ í…ŒìŠ¤íŠ¸
    </button>
  </div>
</div>

<!-- í…ìŠ¤íŠ¸ ëª©ë¡ -->
<div class="space-y-3">
  {% for text in texts %}
  <div id="text-card-{{ text.id }}"
    class="flex justify-between items-center p-4 rounded-lg border hover:shadow-md transition"
    data-source="{{ text.source }}"
    style="background-color: {% if text.test_count >= 5 %}#f3e8ff{% else %}#ffffff{% endif %};">
    
    <div>
      <p class="font-medium text-gray-800">{{ text.title }}</p>
      <p class="text-sm text-gray-500">
        ì €ì¥ëœ ë‹¨ì–´: <span id="word-count-{{ text.id }}">{{ text.word_count }}</span>ê°œ Â· 
        <span class="text-sm">ì•„ëŠ” ë‹¨ì–´:</span>
        <span id="learned-count-{{ text.id }}" class="font-semibold text-gray-700">{{ text.learned_count or 0 }}</span>
        <span class="text-gray-500">/</span>
        <span class="text-gray-600">{{ text.word_count }}</span>
      </p>
    </div>

    <div class="flex items-center space-x-2">
      <button class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded"
        onclick="openTextModal('{{ text.id }}', '{{ text.title }}', `{{ text.content|e }}`)">ì½ê¸°</button>
      <a href="/flashcards/{{ text.id }}" class="bg-indigo-500 hover:bg-indigo-600 text-white px-3 py-1 rounded">ì•”ê¸°ì¹´ë“œ</a>
      <a href="/test/{{ text.id }}" class="bg-purple-500 hover:bg-purple-600 text-white px-3 py-1 rounded">TEST</a>
      <button onclick="deleteText('{{ text.id }}')" class="bg-red-100 hover:bg-red-200 text-red-600 rounded px-2 py-1">ğŸ—‘</button>
    </div>
  </div>
  {% endfor %}
</div>


<!-- âœ… ëª¨ë¥´ëŠ” ë‹¨ì–´ í…ŒìŠ¤íŠ¸ ëª¨ë‹¬ -->
<div id="unknownTestModal" class="fixed inset-0 hidden items-center justify-center bg-black/60 z-50 backdrop-blur-sm">
  <div class="bg-white rounded-2xl shadow-xl w-[90%] max-w-3xl p-6">
    <div class="flex justify-between items-center border-b pb-3 mb-4">
      <h3 class="text-xl font-semibold text-gray-800">ëª¨ë¥´ëŠ” ë‹¨ì–´ í…ŒìŠ¤íŠ¸</h3>
      <button onclick="closeUnknownTestModal()" class="text-gray-500 hover:text-gray-700 text-2xl leading-none">&times;</button>
    </div>

    <div class="mb-3">
      <label class="block font-medium text-gray-700 mb-1">ì¶œì²˜ ì„ íƒ</label>
      <select id="unknownSource" class="w-full border rounded-md px-3 py-2" onchange="loadTitlesForSource()">
        <option value="">ì¶œì²˜ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>
        {% for src in sources %}
          <option value="{{ src }}">{{ src }}</option>
        {% endfor %}
      </select>
    </div>

    <div class="mb-3">
      <label class="block font-medium text-gray-700 mb-1">í…ìŠ¤íŠ¸ ì„ íƒ (ë³µìˆ˜ ì„ íƒ ê°€ëŠ¥)</label>
      <div id="titlesList" class="max-h-48 overflow-y-auto border rounded p-2">
        <!-- ì²´í¬ë°•ìŠ¤ë¡œ í…ìŠ¤íŠ¸ ëª©ë¡ì´ ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤ -->
      </div>
    </div>

    <div class="text-right">
      <button type="button" onclick="closeUnknownTestModal()" class="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300">ì·¨ì†Œ</button>
      <button type="button" onclick="startUnknownTest()" class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700">í…ŒìŠ¤íŠ¸ ì‹œì‘</button>
    </div>
  </div>
</div>


<!-- âœ… Tailwind ê¸°ë°˜ ì—…ë¡œë“œ ëª¨ë‹¬ -->
<div id="uploadModal"
     class="fixed inset-0 hidden items-center justify-center bg-black/60 z-50 backdrop-blur-sm">
  <div class="bg-white rounded-2xl shadow-xl w-[90%] max-w-3xl max-h-[90vh] overflow-y-auto p-6">
    <div class="flex justify-between items-center border-b pb-3 mb-4">
      <h3 class="text-xl font-semibold text-gray-800">í…ìŠ¤íŠ¸ ë° ë‹¨ì–´ ì—…ë¡œë“œ</h3>
      <button onclick="closeUploadModal()" class="text-gray-500 hover:text-gray-700 text-2xl leading-none">&times;</button>
    </div>

    <p class="text-gray-600 mb-4">í…ìŠ¤íŠ¸ë¥¼ ì§ì ‘ ì…ë ¥í•˜ê±°ë‚˜ ë‹¨ì–´ë¥¼ ì¶”ê°€í•´ë³´ì„¸ìš”.</p>

    <!-- íƒ­ ë²„íŠ¼ -->
    <div class="flex border-b mb-4">
      <button id="tabTextBtn" class="flex-1 py-2 text-center font-medium text-blue-600 border-b-2 border-blue-600"
              onclick="switchTab('text')">í…ìŠ¤íŠ¸ ì—…ë¡œë“œ</button>
      <button id="tabWordBtn" class="flex-1 py-2 text-center font-medium text-gray-500 hover:text-blue-600"
              onclick="switchTab('word')">ë‹¨ì–´ ì—…ë¡œë“œ</button>
    </div>

    <!-- í…ìŠ¤íŠ¸ ì—…ë¡œë“œ í¼ -->
    <div id="textUploadTab" class="block">
      <form id="uploadTextForm">
        <div class="mb-3">
          <label class="block font-medium text-gray-700 mb-1">í…ìŠ¤íŠ¸ ì œëª©</label>
          <input type="text" id="textTitle" class="w-full border rounded-md px-3 py-2" placeholder="ì˜ˆ: 01-1 bluegil" required>
        </div>
        <div class="mb-3">
          <label class="block font-medium text-gray-700 mb-1">ì¶œì²˜</label>
          <input type="text" id="textSource" class="w-full border rounded-md px-3 py-2" placeholder="ì¶œì²˜ë¥¼ ì…ë ¥í•˜ì„¸ìš”">
        </div>
        <div class="mb-3">
          <label class="block font-medium text-gray-700 mb-1">ë³¸ë¬¸ ë‚´ìš©</label>
          <textarea id="textContent" class="w-full border rounded-md px-3 py-2 h-40"
                    placeholder="í…ìŠ¤íŠ¸ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”"></textarea>
        </div>
        <div class="text-right">
          <button type="button" onclick="closeUploadModal()" class="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300">ì·¨ì†Œ</button>
          <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">ì €ì¥</button>
        </div>
      </form>
    </div>

    <!-- ë‹¨ì–´ ì—…ë¡œë“œ í¼ -->
    <div id="wordUploadTab" class="hidden">
      <form id="uploadWordsForm">
        <div class="mb-3">
          <label class="block font-medium text-gray-700 mb-1">í…ìŠ¤íŠ¸ ì„ íƒ</label>
          <select id="textSelect" class="w-full border rounded-md px-3 py-2">
            <option value="">í…ìŠ¤íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>
            {% for t in texts %}
              <option value="{{ t.id }}">{{ t.title }}</option>
            {% endfor %}
          </select>
        </div>
        <div class="mb-3">
          <label class="block font-medium text-gray-700 mb-1">ë‹¨ì–´ ëª©ë¡ (í•œ ì¤„ë‹¹ í•˜ë‚˜ì”©)</label>
          <textarea id="wordsInput" class="w-full border rounded-md px-3 py-2 h-40"
                    placeholder="ì˜ˆì‹œ:\narchaeologist\tê³ ê³ í•™ì\ncodices\t(codexì˜ ë³µìˆ˜) ê³ ë¬¸ì„œ\nconfederation\tì¡°í•©"></textarea>
        </div>

        <div class="mt-3">
          <h6 class="font-semibold mb-2">ì…ë ¥ëœ ë‹¨ì–´ ë¯¸ë¦¬ë³´ê¸°</h6>
          <table class="w-full text-sm border border-gray-300">
            <thead class="bg-gray-100">
              <tr>
                <th class="border px-2 py-1 w-12">ID</th>
                <th class="border px-2 py-1 w-1/3">ë‹¨ì–´</th>
                <th class="border px-2 py-1">ëœ»</th>
              </tr>
            </thead>
            <tbody id="previewTable"></tbody>
          </table>
        </div>

        <div class="text-right mt-4">
          <button type="button" onclick="closeUploadModal()" class="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300">ì·¨ì†Œ</button>
          <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">ì €ì¥</button>
        </div>
      </form>
    </div>
  </div>
</div>
<!-- âœ… ë‹¨ì–´ ê´€ë¦¬ ëª¨ë‹¬ -->
<div id="wordManagerModal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center z-50 backdrop-blur-sm">
  <div class="bg-white rounded-2xl shadow-2xl w-[90%] max-w-3xl p-8">
    <h3 class="text-xl font-semibold mb-4 text-gray-800">ë‹¨ì–´ ê´€ë¦¬</h3>

    <!-- âœ… ì¶œì²˜ ì½¤ë³´ë°•ìŠ¤ -->
    <label class="block mb-2 text-gray-700">ì¶œì²˜ ì„ íƒ</label>
    <select id="sourceSelector" class="border rounded px-3 py-2 w-full mb-4" onchange="loadTitlesBySource()">
      <option value="">ì¶œì²˜ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>
    </select>

    <!-- âœ… í…ìŠ¤íŠ¸ ì œëª© ì½¤ë³´ë°•ìŠ¤ -->
    <label class="block mb-2 text-gray-700">í…ìŠ¤íŠ¸ ì„ íƒ</label>
    <select id="textSelector" class="border rounded px-3 py-2 w-full mb-4" onchange="loadWordsByText()">
      <option value="">ì œëª©ì„ ì„ íƒí•˜ì„¸ìš”</option>
    </select>

    <!-- âœ… ë‹¨ì–´ ëª©ë¡ ì˜ì—­ -->
    <div id="wordList" class="max-h-[50vh] overflow-y-auto border rounded p-3 bg-gray-50"></div>

    <div class="text-right mt-4">
      <button onclick="closeWordManager()" class="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300">ë‹«ê¸°</button>
    </div>
  </div>
</div>



<!-- âœ… í…ìŠ¤íŠ¸ ì½ê¸° ëª¨ë‹¬ -->
<div id="textModal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center z-50 backdrop-blur-sm">
  <div class="bg-white rounded-2xl shadow-2xl w-[90%] max-w-4xl p-10 max-h-[80vh] overflow-y-auto border border-gray-200">
    
    <h3 id="modalTitle" class="text-center text-2xl font-medium mb-8 text-gray-800 tracking-tight font-['Noto_Serif']"></h3>

    <!-- âœ… ìˆ˜ì •/ë‹«ê¸° ë²„íŠ¼ (ê°™ì€ ì¤„ì— ë°°ì¹˜) -->
    <div class="flex justify-end mb-3 space-x-3">
      <button onclick="closeTextModal()" class="px-4 py-1 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded">ë‹«ê¸°</button>
      <button id="editToggleBtn" onclick="toggleEditMode()" 
              class="bg-yellow-400 hover:bg-yellow-500 text-white px-3 py-1 rounded">ìˆ˜ì •</button>
    </div>

    <div id="modalContent" class="text-[17px] text-gray-700 leading-[1.9] font-['Noto_Serif'] text-justify whitespace-pre-line"></div>
  </div>
</div>


<!-- âœ… JS -->
<script>
function openUploadModal() {
  document.getElementById('uploadModal').classList.remove('hidden');
  document.getElementById('uploadModal').classList.add('flex');
}
function closeUploadModal() {
  document.getElementById('uploadModal').classList.add('hidden');
  document.getElementById('uploadModal').classList.remove('flex');
}


/* ========== ëª¨ë¥´ëŠ” ë‹¨ì–´ í…ŒìŠ¤íŠ¸ ë¡œì§ ========== */
function openUnknownTestModal() {
  console.log('[DEBUG] openUnknownTestModal called');
  debugLog('[DEBUG] openUnknownTestModal called');
  const modal = document.getElementById('unknownTestModal');
  if (!modal) { console.error('[DEBUG] unknownTestModal element not found'); debugLog('[ERROR] unknownTestModal element not found'); alert('ëª¨ë‹¬ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.'); return; }
  modal.classList.remove('hidden');
  modal.classList.add('flex');
  // Pre-load titles for the currently selected source (if any)
  try { loadTitlesForSource(); } catch (err) { console.error('[DEBUG] loadTitlesForSource failed', err); debugLog('[ERROR] loadTitlesForSource failed: ' + err); }
}
function closeUnknownTestModal() {
  const modal = document.getElementById('unknownTestModal');
  if (modal) { modal.classList.add('hidden'); modal.classList.remove('flex'); }
}

async function loadTitlesForSource() {
  console.log('[DEBUG] loadTitlesForSource called');
  debugLog('[DEBUG] loadTitlesForSource called');
  const src = document.getElementById('unknownSource').value;
  const list = document.getElementById('titlesList');
  if (!list) { console.error('[DEBUG] titlesList element not found'); debugLog('[ERROR] titlesList element not found'); return; }
  list.innerHTML = '';
  if (!src) return;

  try {
    const res = await fetch(`/get_titles_by_source/${encodeURIComponent(src)}`);
    if (!res.ok) { console.error('[DEBUG] get_titles_by_source failed', res.status); debugLog('[ERROR] get_titles_by_source failed: ' + res.status); return; }
    const titles = await res.json();
    titles.forEach(t => {
      const id = t.id;
      const row = document.createElement('div');
      row.className = 'flex items-center justify-between py-1 px-2';
      row.innerHTML = `
        <label class="flex items-center gap-2">
          <input type="checkbox" class="title-checkbox" value="${id}">
          <span class="text-sm">${t.title}</span>
        </label>`;
      list.appendChild(row);
    });
    debugLog('[DEBUG] titles loaded: ' + titles.length);
  } catch (err) {
    console.error('[DEBUG] loadTitlesForSource error', err);
    debugLog('[ERROR] loadTitlesForSource error: ' + err);
    alert('í…ìŠ¤íŠ¸ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.');
  }
}

async function startUnknownTest() {
  console.log('[DEBUG] startUnknownTest called');
  debugLog('[DEBUG] startUnknownTest called');
  const checked = [...document.querySelectorAll('.title-checkbox:checked')].map(cb => cb.value);
  if (checked.length === 0) return alert('í•˜ë‚˜ ì´ìƒì˜ í…ìŠ¤íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”.');

  try {
    const btn = document.getElementById('openUnknownTestBtn');
    if (btn) btn.disabled = true;

    const res = await fetch('/api/unlearned_words', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text_ids: checked })
    });

    debugLog('[DEBUG] /api/unlearned_words status: ' + res.status);
    const data = await res.json();
    if (!res.ok) { alert(data.error || 'ë‹¨ì–´ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.'); return; }
    debugLog('[DEBUG] /api/unlearned_words returned ' + (data.length || 0) + ' words');
    if (!data.length) return alert('ì„ íƒí•œ í…ìŠ¤íŠ¸ì˜ ëª¨ë¥´ëŠ” ë‹¨ì–´ê°€ ì—†ìŠµë‹ˆë‹¤.');

    // ì‹œì‘: client-side í…ŒìŠ¤íŠ¸ ëª¨ë‹¬ì— ë‹¨ì–´ë¥¼ ì „ë‹¬
    startClientTest(data);
    closeUnknownTestModal();
  } catch (err) {
    console.error('[DEBUG] startUnknownTest error', err);
    debugLog('[ERROR] startUnknownTest error: ' + err);
    alert('í…ŒìŠ¤íŠ¸ë¥¼ ì‹œì‘í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.');
  } finally {
    const btn = document.getElementById('openUnknownTestBtn');
    if (btn) btn.disabled = false;
  }
}

/* íƒ­ ì „í™˜ */
function switchTab(tab) {
  const textTab = document.getElementById('textUploadTab');
  const wordTab = document.getElementById('wordUploadTab');
  const textBtn = document.getElementById('tabTextBtn');
  const wordBtn = document.getElementById('tabWordBtn');
  if (tab === 'text') {
    textTab.classList.remove('hidden');
    wordTab.classList.add('hidden');
    textBtn.classList.add('text-blue-600', 'border-blue-600');
    textBtn.classList.remove('text-gray-500');
    wordBtn.classList.remove('text-blue-600', 'border-blue-600');
    wordBtn.classList.add('text-gray-500');
  } else {
    textTab.classList.add('hidden');
    wordTab.classList.remove('hidden');
    wordBtn.classList.add('text-blue-600', 'border-blue-600');
    wordBtn.classList.remove('text-gray-500');
    textBtn.classList.remove('text-blue-600', 'border-blue-600');
    textBtn.classList.add('text-gray-500');
  }
}

/* ë¯¸ë¦¬ë³´ê¸° */
const wordsInput = document.getElementById('wordsInput');
const previewBody = document.getElementById('previewTable');
if (wordsInput) {
  wordsInput.addEventListener('input', () => {
    previewBody.innerHTML = '';
    const lines = wordsInput.value.trim().split('\n').filter(l => l.trim());
    lines.forEach((line, i) => {
      const [word, meaning] = line.split(/\t| {2,}/);
      const row = `<tr><td class="border px-2 text-center">${i + 1}</td><td class="border px-2">${word || ''}</td><td class="border px-2">${meaning || ''}</td></tr>`;
      previewBody.insertAdjacentHTML('beforeend', row);
    });
  });
}

/* í…ìŠ¤íŠ¸ ì—…ë¡œë“œ */
document.getElementById('uploadTextForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  const title = document.getElementById('textTitle').value.trim();
  const source = document.getElementById('textSource').value.trim();
  const content = document.getElementById('textContent').value.trim();

  const res = await fetch('/upload_text', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ title, source, content })
  });
  const data = await res.json();
  alert(data.message || data.error);
  closeUploadModal();
  location.reload();
});

/* ë‹¨ì–´ ì—…ë¡œë“œ */
document.getElementById('uploadWordsForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  const text_id = document.getElementById('textSelect').value;
  const rawText = document.getElementById('wordsInput').value.trim();
  if (!text_id || !rawText) return alert("í…ìŠ¤íŠ¸ì™€ ë‹¨ì–´ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.");

  const lines = rawText.split('\n').filter(l => l.trim());
  const words = lines.map(line => {
    const [word, meaning] = line.split(/\t| {2,}/);
    return { word: word?.trim(), meaning: meaning?.trim() };
  });

  const res = await fetch('/upload_words', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ text_id, words })
  });
  const data = await res.json();
  alert(data.message || data.error);
  closeUploadModal();
  location.reload();
});
/* âœ… ì¶œì²˜ í•„í„° ë™ì‘ (data-source ì†ì„± ê¸°ë°˜) */
const sourceFilter = document.getElementById("sourceFilter");
if (sourceFilter) {
  sourceFilter.addEventListener("change", () => {
    const selected = sourceFilter.value.trim().toLowerCase();
    const cards = document.querySelectorAll(".space-y-3 > div.flex.justify-between.items-center");

    cards.forEach(card => {
      // data-source ì†ì„±ì—ì„œ ì¶œì²˜ ì½ê¸°
      const cardSource = (card.dataset.source || "").trim().toLowerCase();

      // í•„í„°ë§ ì¡°ê±´
      if (!selected || cardSource === selected) {
        card.style.display = "flex";
      } else {
        card.style.display = "none";
      }
    });
  });
}

let editMode = false;

/* âœ… ì½ê¸° ëª¨ë‹¬ì—ì„œ ìˆ˜ì • ëª¨ë“œ í† ê¸€ */
function toggleEditMode() {
  const btn = document.getElementById("editToggleBtn");
  const contentDiv = document.getElementById("modalContent");
  
  if (!editMode) {
    // ìˆ˜ì • ëª¨ë“œ ì§„ì…
    const currentText = contentDiv.innerText.trim();
    contentDiv.innerHTML = `<textarea id="editTextarea" class="w-full border rounded-md p-3 h-96">${currentText}</textarea>
                            <div class="text-right mt-3">
                              <button onclick="saveEditedText()" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">ì €ì¥</button>
                            </div>`;
    btn.textContent = "ì·¨ì†Œ";
    btn.classList.replace("bg-yellow-400", "bg-gray-400");
  } else {
    // ì›ë˜ ì½ê¸° ëª¨ë“œë¡œ ë³µê·€ (ìƒˆë¡œê³ ì¹¨ìœ¼ë¡œ ë³µì›)
    location.reload();
  }
  editMode = !editMode;
}

/* âœ… ìˆ˜ì • ì €ì¥ */
async function saveEditedText() {
  const id = document.getElementById("modalTitle").dataset.id;  // âœ… ì´ ì¤„ë¡œ êµì²´
  const title = document.getElementById("modalTitle").innerText;
  const content = document.getElementById("editTextarea").value.trim();

  const res = await fetch("/update_text", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ id, title, content })
  });

  const data = await res.json();
  alert(data.message || data.error);
  location.reload();
}
/* âœ… ë‹¨ì–´ ê´€ë¦¬ ëª¨ë‹¬ ì—´ê¸° */
async function openWordManager() {
  const modal = document.getElementById("wordManagerModal");
  modal.classList.remove("hidden");

  // ì¶œì²˜ ë¦¬ìŠ¤íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸°
  const res = await fetch("/get_sources");
const sources = await res.json();
const selector = document.getElementById("sourceSelector");
selector.innerHTML = '<option value="">ì¶œì²˜ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>';
sources.forEach(s => {
  selector.innerHTML += `<option value="${s.source}">${s.source}</option>`;
});


  // ì œëª© ì´ˆê¸°í™”
  document.getElementById("textSelector").innerHTML = '<option value="">ì œëª©ì„ ì„ íƒí•˜ì„¸ìš”</option>';
  document.getElementById("wordList").innerHTML = "";
}

/* âœ… ëª¨ë‹¬ ë‹«ê¸° */
function closeWordManager() {
  document.getElementById("wordManagerModal").classList.add("hidden");
}

/* âœ… ì¶œì²˜ ì„ íƒ ì‹œ ì œëª© ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° */
async function loadTitlesBySource() {
  const source = document.getElementById("sourceSelector").value;
  const selector = document.getElementById("textSelector");

  if (!source) {
    selector.innerHTML = '<option value="">ì œëª©ì„ ì„ íƒí•˜ì„¸ìš”</option>';
    return;
  }

  const res = await fetch(`/get_titles_by_source/${encodeURIComponent(source)}`);
  const titles = await res.json();

  selector.innerHTML = '<option value="">ì œëª©ì„ ì„ íƒí•˜ì„¸ìš”</option>';
  titles.forEach(t => {
    selector.innerHTML += `<option value="${t.id}">${t.title}</option>`;
  });

  document.getElementById("wordList").innerHTML = "";
}


/* âœ… ì œëª© ì„ íƒ ì‹œ ë‹¨ì–´ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° */
async function loadWordsByText() {
  const textId = document.getElementById("textSelector").value;
  if (!textId) return;

  const res = await fetch(`/get_words_by_text/${textId}`);
  const data = await res.json();

  const list = document.getElementById("wordList");
  if (data.length === 0) {
    list.innerHTML = "<p class='text-gray-500'>ì €ì¥ëœ ë‹¨ì–´ê°€ ì—†ìŠµë‹ˆë‹¤.</p>";
    return;
  }

  list.innerHTML = data.map(w => `
  <div class="flex items-center gap-2 mb-2 bg-white border rounded p-2 word-row">

    <!-- âœ… ì²´í¬ë°•ìŠ¤(ì•„ëŠ” ë‹¨ì–´) -->
    <input type="checkbox"
           class="w-5 h-5 accent-blue-500 cursor-pointer"
           ${Number(w.is_learned) === 1 ? "checked" : ""}
           onchange="toggleLearned('${w.id}', this.checked)">

    <input value="${w.word}"
           class="border px-2 py-1 rounded w-1/3"
           id="word-${w.id}">

    <input value="${w.meaning || ''}"
           class="border px-2 py-1 rounded w-1/2"
           id="meaning-${w.id}">

    <div class="flex space-x-2 ml-auto actions">
      <!-- Small icon buttons; visible on hover -->
      <button class="bg-transparent hover:bg-gray-100 text-gray-700 px-2 py-1 rounded text-sm"
              onclick="updateWord('${w.id}')" title="ìˆ˜ì •">âœï¸</button>

      <button class="bg-transparent hover:bg-gray-100 text-gray-700 px-2 py-1 rounded text-sm"
              onclick="deleteWord('${w.id}')" title="ì‚­ì œ">ğŸ—‘ï¸</button>
    </div>
  </div>
`).join('');
}
async function toggleLearned(id, checked) {
  const res = await fetch("/api/word/learned", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ word_id: id, is_learned: checked })
  });

  const data = await res.json().catch(() => ({}));
  if (!res.ok || data.ok === false) {
    alert(data.error || "ì²´í¬ ì €ì¥ ì‹¤íŒ¨");
  }
}
/* âœ… ë‹¨ì–´ ìˆ˜ì • */
async function updateWord(id) {
  const word = document.getElementById(`word-${id}`).value.trim();
  const meaning = document.getElementById(`meaning-${id}`).value.trim();
  const res = await fetch("/update_word", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ id, word, meaning })
  });
  const data = await res.json();
  alert(data.message || data.error);
}

/* âœ… ë‹¨ì–´ ì‚­ì œ */
async function deleteWord(id) {
  if (!confirm("ì •ë§ ì´ ë‹¨ì–´ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
  const res = await fetch(`/delete_word/${id}`, { method: "DELETE" });
  const data = await res.json();
  alert(data.message || data.error);
  loadWordsByText(); // ìƒˆë¡œê³ ì¹¨
}


/* í…ìŠ¤íŠ¸ ë³´ê¸° ëª¨ë‹¬ */
async function openTextModal(id, title, content) {
  const modal = document.getElementById('textModal');
  const modalTitle = document.getElementById('modalTitle');
  const modalContent = document.getElementById('modalContent');

  modalTitle.setAttribute('data-id', id);  // âœ… id ì €ì¥
  modalTitle.innerText = title;

  // Escape helper for safe HTML
  function escapeHtml(str) {
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  // Default: show raw content (escaped)
  let escaped = escapeHtml(content);

  // Try to fetch saved words and highlight them inline
  try {
    const res = await fetch(`/get_words_by_text/${encodeURIComponent(id)}`);
    if (res.ok) {
      const words = await res.json();
      if (words && words.length > 0) {
        // Sort by length desc to avoid partial replacements and keep word + learned flag
        const wordsSorted = words.filter(w => w.word).sort((a,b) => (b.word.length || 0) - (a.word.length || 0));
        // Replace occurrences with <mark> using different classes for learned/unknown
        wordsSorted.forEach(wobj => {
          try {
            const rawWord = wobj.word;
            const w = escapeHtml(rawWord);
            const pattern = w.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            const re = new RegExp('\\b' + pattern + '\\b', 'gi');
            const cls = (wobj.is_learned == 1 || wobj.is_learned === true) ? 'bg-green-200 text-green-800 rounded px-0.5' : 'bg-yellow-200 rounded px-0.5';
            escaped = escaped.replace(re, function(m){ return `<mark class="${cls}">${m}</mark>`; });
          } catch (innerErr) {
            debugLog('[ERROR] highlight word failed: ' + innerErr);
          }
        });
      } else {
        debugLog('[DEBUG] get_words_by_text returned no words');
      }
    } else {
      debugLog('[ERROR] get_words_by_text failed: ' + res.status);
    }
  } catch (err) {
    debugLog('[ERROR] fetch words error: ' + err);
  }

  modalContent.innerHTML = `<div style="white-space: pre-line; line-height:1.9;" class="text-[17px] text-gray-700 font-['Noto_Serif']">${escaped}</div>`;

  // attach single-click handler to allow adding unknown words
  if (!modalContent.dataset.wordClick) {
    // Debounce clicks to avoid multiple requests
    let _wordClickInProgress = false;
    modalContent.addEventListener('click', async function(e){
      if (_wordClickInProgress) return;
      _wordClickInProgress = true;
      try {
        const word = getWordAtPoint(e.clientX, e.clientY);
        if (!word || word.length < 2) { _wordClickInProgress = false; return; }
        const textId = modalTitle.dataset.id;
        if (!textId) { _wordClickInProgress = false; return; }

        debugLog('[DEBUG] clicked word (toggle attempt): ' + word);

        // Try to add first. If server reports it already exists (created=false), then remove it.
        const addRes = await addWordFromText(textId, word);
        if (addRes && addRes.ok) {
          if (addRes.created === true) {
            highlightWordInModal(word);
            showTempBadge(e.clientX, e.clientY, 'ì¶”ê°€ë¨');
          } else {
            // already existed â€” attempt to remove to toggle
            const remRes = await removeWordFromText(textId, word);
            if (remRes && remRes.ok && remRes.deleted) {
              unhighlightWordInModal(word);
              showTempBadge(e.clientX, e.clientY, 'ì‚­ì œë¨');
            } else if (remRes && remRes.ok && !remRes.deleted) {
              showTempBadge(e.clientX, e.clientY, 'ì—†ìŒ');
            } else if (remRes && remRes.error) {
              debugLog('[ERROR] removeWord error after add reported exists: ' + remRes.error);
            }
          }
        } else if (addRes && addRes.error) {
          debugLog('[ERROR] addWord error: ' + addRes.error);
        }
      } catch(err) { debugLog('[ERROR] word click handler (toggle): ' + err); }
      _wordClickInProgress = false;
    });
    modalContent.dataset.wordClick = '1';
  }

  modal.classList.remove('hidden');
}

function closeTextModal() {
  document.getElementById('textModal').classList.add('hidden');
}



</script>

<!-- âœ… Client-side test modal (used by ëª¨ë¥´ëŠ” ë‹¨ì–´ í…ŒìŠ¤íŠ¸) -->
<div id="clientTestModal" class="fixed inset-0 hidden bg-gray-900 bg-opacity-50 flex items-center justify-center z-50">
  <div class="bg-white rounded-xl shadow-lg w-[550px] p-6 relative">
    <div class="flex justify-between items-center mb-4">
      <h2 class="text-xl font-semibold text-gray-800">ë‹¨ì–´ í…ŒìŠ¤íŠ¸</h2>
      <button onclick="closeClientTestModal()" class="text-gray-500 hover:text-gray-700">âœ•</button>
    </div>

    <div class="mb-4">
      <div class="h-2 bg-gray-200 rounded">
        <div id="clientProgressBar" class="h-2 bg-indigo-500 rounded" style="width:0%"></div>
      </div>
      <p class="text-sm text-gray-600 mt-1">
        <span id="clientCurrentQuestion">0</span> / <span id="clientTotalQuestions">0</span>
      </p>
    </div>

    <div class="text-center mb-6">
      <p id="clientQuestionWord" class="text-3xl font-bold text-gray-800 mb-3"></p>
      <button id="clientSoundBtn" class="text-indigo-500 hover:text-indigo-700 mb-2 text-sm">ğŸ”Š ë°œìŒ ë“£ê¸°</button>
      <p id="clientSourceText" class="text-gray-500 text-sm"></p>
    </div>

    <div id="clientOptionsContainer" class="space-y-2"></div>
  </div>
</div>

<script>
// Debug helper (console only)
function debugLog(msg){
  console.log(msg);
}

// Utility: Fisher-Yates shuffle (returns a new array)
function shuffle(arr) {
  if (!Array.isArray(arr)) return [];
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// get the word under pointer (x,y)
function getWordAtPoint(x, y) {
  let range;
  if (document.caretRangeFromPoint) {
    range = document.caretRangeFromPoint(x, y);
  } else if (document.caretPositionFromPoint) {
    const pos = document.caretPositionFromPoint(x, y);
    range = document.createRange();
    range.setStart(pos.offsetNode, pos.offset);
    range.setEnd(pos.offsetNode, pos.offset);
  }
  if (!range) return '';
  const node = range.startContainer;
  if (!node || node.nodeType !== Node.TEXT_NODE) return '';
  const text = node.textContent;
  const offset = range.startOffset;
  let start = offset, end = offset;
  // accept letters (including non-ascii) and hyphens/apostrophes
  const isChar = ch => /[\p{L}\-']/u.test(ch);
  while (start > 0 && isChar(text[start - 1])) start--;
  while (end < text.length && isChar(text[end])) end++;
  return text.slice(start, end).trim();
}

// Add word to server and return response
async function addWordFromText(textId, word) {
  try {
    const res = await fetch('/api/add_word', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text_id: textId, word })
    });
    return await res.json();
  } catch (err) {
    debugLog('[ERROR] addWordFromText failed: ' + err);
    return null;
  }
}

// Remove word from server
async function removeWordFromText(textId, word) {
  try {
    const res = await fetch('/api/remove_word', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text_id: textId, word })
    });
    return await res.json();
  } catch (err) {
    debugLog('[ERROR] removeWordFromText failed: ' + err);
    return null;
  }
}

// Un-highlight all occurrences of a word in the modal
function unhighlightWordInModal(word) {
  if (!word) return;
  const modalContent = document.getElementById('modalContent');
  if (!modalContent) return;
  const escaped = word.replace(/[-\\/\\^$*+?.()|[\\]{}]/g, '\\$&');
  const re = new RegExp('<mark[^>]*>\\s*(' + escaped + ')\\s*<\\/mark>', 'gi');
  modalContent.innerHTML = modalContent.innerHTML.replace(re, function(m, p1){ return p1; });
}

// Highlight a single word in the modal body (wrap with <mark>)
// learned: true => green; false => yellow
function highlightWordInModal(word, learned=false) {
  if (!word) return;
  const modalContent = document.getElementById('modalContent');
  if (!modalContent) return;
  const escaped = word.replace(/[-\\/\\^$*+?.()|[\\]{}]/g, '\\$&');
  const re = new RegExp('\\b' + escaped + '\\b', 'gi');
  const cls = learned ? 'bg-green-200 text-green-800 rounded px-0.5' : 'bg-yellow-200 rounded px-0.5';
  modalContent.innerHTML = modalContent.innerHTML.replace(re, function(m){
    return `<mark class="${cls}">${m}</mark>`;
  });
}

// Show a small temporary badge at (x,y)
function showTempBadge(x, y, text) {
  const badge = document.createElement('div');
  badge.innerText = text || 'ì¶”ê°€ë¨';
  badge.style.position = 'fixed';
  badge.style.left = (x + 6) + 'px';
  badge.style.top = (y + 6) + 'px';
  badge.style.background = 'rgba(59,130,246,0.95)';
  badge.style.color = '#fff';
  badge.style.padding = '6px 8px';
  badge.style.borderRadius = '6px';
  badge.style.zIndex = 99999;
  badge.style.fontSize = '12px';
  document.body.appendChild(badge);
  setTimeout(()=> { badge.style.transition = 'opacity 0.4s'; badge.style.opacity = '0'; setTimeout(()=>badge.remove(), 450); }, 900);
}

// Client test state
let clientQuestions = [];
let clientCurrentIndex = 0;
let clientScore = 0;
let clientTotal = 0;
let clientStartTime;
let clientWrongWords = [];

function startClientTest(words) {
  clientQuestions = shuffle(words);
  clientCurrentIndex = 0;
  clientScore = 0;
  clientWrongWords = [];
  clientTotal = clientQuestions.length;

  document.getElementById('clientTotalQuestions').innerText = clientTotal;
  document.getElementById('clientTestModal').classList.remove('hidden');
  clientStartTime = new Date();
  showClientQuestion();
}

function showClientQuestion() {
  const q = clientQuestions[clientCurrentIndex];
  document.getElementById('clientQuestionWord').innerText = q.word;
  document.getElementById('clientSourceText').innerText = 'ì¶œì²˜: ' + (q.text_title || '');
  document.getElementById('clientCurrentQuestion').innerText = clientCurrentIndex + 1;
  document.getElementById('clientProgressBar').style.width = ((clientCurrentIndex) / clientTotal * 100) + '%';

  const allMeanings = clientQuestions.map(x => x.meaning);
  const options = [q.meaning, ...shuffle(allMeanings.filter(m => m !== q.meaning)).slice(0,3)];
  renderClientOptions(shuffle(options), q.meaning);
}

function renderClientOptions(options, correct) {
  const container = document.getElementById('clientOptionsContainer');
  container.innerHTML = '';
  options.forEach((opt, idx) => {
    const btn = document.createElement('button');
    btn.className = 'w-full border border-gray-300 rounded-lg py-2 text-gray-800 hover:bg-indigo-50 transition';
    btn.innerHTML = `<span class="font-semibold mr-2">${String.fromCharCode(65 + idx)}.</span> ${opt}`;
    btn.onclick = () => clientCheckAnswer(opt === correct, btn, correct);
    container.appendChild(btn);
  });
}

function clientCheckAnswer(isCorrect, btn, correct) {
  const buttons = document.querySelectorAll('#clientOptionsContainer button');
  buttons.forEach(b => b.disabled = true);
  const q = clientQuestions[clientCurrentIndex];
  if (isCorrect) {
    btn.classList.add('bg-green-500', 'text-white');
    clientScore++;
  } else {
    btn.classList.add('bg-red-500', 'text-white');
    const correctBtn = Array.from(buttons).find(b => b.innerText.includes(correct));
    if (correctBtn) correctBtn.classList.add('bg-green-500', 'text-white');
    clientWrongWords.push({ word: q.word, meaning: q.meaning });
  }

  setTimeout(() => {
    clientCurrentIndex++;
    if (clientCurrentIndex < clientTotal) showClientQuestion();
    else clientFinishTest();
  }, 1000);
}

function clientFinishTest() {
  const endTime = new Date();
  const duration = Math.floor((endTime - clientStartTime) / 1000);
  const percent = Math.round((clientScore / clientTotal) * 100);

  // Save results
  fetch('/save_test_result', {
    method: 'POST', headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ test_name: clientQuestions[0]?.text_title || 'Unknown', total_questions: clientTotal, correct_answers: clientScore, score: percent, duration: duration, wrong_words: clientWrongWords })
  }).then(res => res.json()).then(data => {
    alert('í…ŒìŠ¤íŠ¸ ì™„ë£Œ: ' + percent + '%');
    closeClientTestModal();
    location.reload();
  }).catch(() => { alert('ê²°ê³¼ ì €ì¥ ì‹¤íŒ¨'); closeClientTestModal(); });
}

function closeClientTestModal() {
  document.getElementById('clientTestModal').classList.add('hidden');
}
</script>

<!-- âœ… ì‚¬ìš©ì ê´€ë¦¬ ëª¨ë‹¬ -->
<div id="userManagerModal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center z-50 backdrop-blur-sm">
  <div class="bg-white rounded-2xl shadow-2xl w-[90%] max-w-4xl p-8 max-h-[90vh] overflow-y-auto">
    <div class="flex justify-between items-center border-b pb-3 mb-4">
      <h3 class="text-2xl font-bold text-gray-800">ì‚¬ìš©ì ê´€ë¦¬</h3>
      <button onclick="closeUserManager()" class="text-gray-500 hover:text-gray-700 text-3xl leading-none">&times;</button>
    </div>

    <!-- ì¶”ê°€ í¼ -->
    <div class="bg-gray-50 rounded-lg p-4 mb-6">
      <h4 class="font-semibold text-lg mb-3 text-gray-700">ìƒˆ ì‚¬ìš©ì-ì¶œì²˜ ì¶”ê°€</h4>
      <div class="flex gap-3 items-end">
        <div class="flex-1">
          <label class="block text-sm font-medium text-gray-700 mb-1">ì‚¬ìš©ìëª…</label>
          <input type="text" id="newUserName" class="w-full border rounded px-3 py-2" placeholder="ì˜ˆ: ë°•ì˜ì§„">
        </div>
        <div class="flex-1">
          <label class="block text-sm font-medium text-gray-700 mb-1">ì¶œì²˜</label>
          <select id="newUserSource" class="w-full border rounded px-3 py-2">
            <option value="">ì¶œì²˜ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>
            <!-- ë™ì ìœ¼ë¡œ ì±„ì›Œì§‘ë‹ˆë‹¤ -->
          </select>
        </div>
        <button onclick="addUser()" class="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 transition">
          ì¶”ê°€
        </button>
      </div>
    </div>

    <!-- ì‚¬ìš©ì ëª©ë¡ í…Œì´ë¸” -->
    <div class="overflow-x-auto">
      <table class="w-full text-sm border-collapse">
        <thead>
          <tr class="bg-gradient-to-r from-purple-100 to-indigo-100">
            <th class="border px-4 py-3 text-left font-semibold text-gray-700">ID</th>
            <th class="border px-4 py-3 text-left font-semibold text-gray-700">ì‚¬ìš©ìëª…</th>
            <th class="border px-4 py-3 text-left font-semibold text-gray-700">ì¶œì²˜</th>
            <th class="border px-4 py-3 text-center font-semibold text-gray-700">ì‘ì—…</th>
          </tr>
        </thead>
        <tbody id="userListTable">
          <!-- ë™ì ìœ¼ë¡œ ì±„ì›Œì§‘ë‹ˆë‹¤ -->
        </tbody>
      </table>
    </div>

    <div class="text-right mt-6">
      <button onclick="closeUserManager()" class="px-6 py-2 bg-gray-200 rounded hover:bg-gray-300 transition">ë‹«ê¸°</button>
    </div>
  </div>
</div>

<script>
// ì‚¬ìš©ì ê´€ë¦¬ ëª¨ë‹¬ ì—´ê¸°
function openUserManager() {
  document.getElementById('userManagerModal').classList.remove('hidden');
  loadSourceOptions();
  loadUserList();
}

// ì‚¬ìš©ì ê´€ë¦¬ ëª¨ë‹¬ ë‹«ê¸°
function closeUserManager() {
  document.getElementById('userManagerModal').classList.add('hidden');
}

// ì¶œì²˜ ëª©ë¡ ë¡œë“œ
function loadSourceOptions() {
  fetch('/get_sources')
    .then(res => res.json())
    .then(sources => {
      const select = document.getElementById('newUserSource');
      select.innerHTML = '<option value="">ì¶œì²˜ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>';
      sources.forEach(src => {
        const option = document.createElement('option');
        option.value = src.source;
        option.textContent = src.source;
        select.appendChild(option);
      });
      // ì „ì—­ ë³€ìˆ˜ì— ì €ì¥í•´ì„œ í…Œì´ë¸”ì—ì„œë„ ì‚¬ìš©
      window.availableSources = sources.map(s => s.source);
    })
    .catch(err => {
      console.error('ì¶œì²˜ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨:', err);
    });
}

// ì‚¬ìš©ì ëª©ë¡ ë¡œë“œ
function loadUserList() {
  fetch('/api/users')
    .then(res => res.json())
    .then(users => {
      const tbody = document.getElementById('userListTable');
      tbody.innerHTML = '';
      
      if (users.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" class="border px-4 py-3 text-center text-gray-500">ë“±ë¡ëœ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤.</td></tr>';
        return;
      }

      users.forEach(user => {
        const tr = document.createElement('tr');
        tr.className = 'hover:bg-gray-50';
        
        // ì¶œì²˜ ë“œë¡­ë‹¤ìš´ ìƒì„±
        let sourceOptions = '<option value="">ì¶œì²˜ ì„ íƒ</option>';
        if (window.availableSources) {
          window.availableSources.forEach(src => {
            const selected = src === user.source ? 'selected' : '';
            sourceOptions += `<option value="${src}" ${selected}>${src}</option>`;
          });
        }
        
        tr.innerHTML = `
          <td class="border px-4 py-2">${user.id}</td>
          <td class="border px-4 py-2">
            <input type="text" id="userName-${user.id}" value="${user.user_name}" 
                   class="w-full px-2 py-1 border rounded focus:border-blue-500">
          </td>
          <td class="border px-4 py-2">
            <select id="userSource-${user.id}" class="w-full px-2 py-1 border rounded focus:border-blue-500">
              ${sourceOptions}
            </select>
          </td>
          <td class="border px-4 py-2 text-center space-x-2">
            <button onclick="updateUser(${user.id})" 
                    class="bg-green-500 text-white px-3 py-1 rounded hover:bg-green-600 text-xs">
              ìˆ˜ì •
            </button>
            <button onclick="deleteUser(${user.id})" 
                    class="bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600 text-xs">
              ì‚­ì œ
            </button>
          </td>
        `;
        tbody.appendChild(tr);
      });
    })
    .catch(err => {
      console.error('ì‚¬ìš©ì ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨:', err);
      alert('ì‚¬ìš©ì ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    });
}

// ì‚¬ìš©ì ì¶”ê°€
function addUser() {
  const userName = document.getElementById('newUserName').value.trim();
  const source = document.getElementById('newUserSource').value.trim();

  if (!userName || !source) {
    alert('ì‚¬ìš©ìëª…ê³¼ ì¶œì²˜ë¥¼ ëª¨ë‘ ì…ë ¥í•˜ì„¸ìš”.');
    return;
  }

  fetch('/api/users', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ user_name: userName, source: source })
  })
    .then(res => res.json())
    .then(data => {
      if (data.ok) {
        alert('ì‚¬ìš©ìê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.');
        document.getElementById('newUserName').value = '';
        document.getElementById('newUserSource').value = '';
        loadUserList();
      } else {
        alert(data.error || 'ì¶”ê°€ ì‹¤íŒ¨');
      }
    })
    .catch(err => {
      console.error('ì‚¬ìš©ì ì¶”ê°€ ì‹¤íŒ¨:', err);
      alert('ì‚¬ìš©ì ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    });
}

// ì‚¬ìš©ì ìˆ˜ì •
function updateUser(userId) {
  const userName = document.getElementById(`userName-${userId}`).value.trim();
  const source = document.getElementById(`userSource-${userId}`).value.trim();

  if (!userName || !source) {
    alert('ì‚¬ìš©ìëª…ê³¼ ì¶œì²˜ë¥¼ ëª¨ë‘ ì…ë ¥í•˜ì„¸ìš”.');
    return;
  }

  fetch(`/api/users/${userId}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ user_name: userName, source: source })
  })
    .then(res => res.json())
    .then(data => {
      if (data.ok) {
        alert('ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');
        loadUserList();
      } else {
        alert(data.error || 'ìˆ˜ì • ì‹¤íŒ¨');
      }
    })
    .catch(err => {
      console.error('ì‚¬ìš©ì ìˆ˜ì • ì‹¤íŒ¨:', err);
      alert('ì‚¬ìš©ì ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    });
}

// ì‚¬ìš©ì ì‚­ì œ
function deleteUser(userId) {
  if (!confirm('ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;

  fetch(`/api/users/${userId}`, { method: 'DELETE' })
    .then(res => res.json())
    .then(data => {
      if (data.ok) {
        alert('ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
        loadUserList();
      } else {
        alert(data.error || 'ì‚­ì œ ì‹¤íŒ¨');
      }
    })
    .catch(err => {
      console.error('ì‚¬ìš©ì ì‚­ì œ ì‹¤íŒ¨:', err);
      alert('ì‚¬ìš©ì ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    });
}
</script>

<script>
// Debug helper (console only)
function debugLog(msg){
  console.log(msg);
}

// Global error handlers
window.addEventListener('error', function(e){
  try { debugLog('[ERROR] ' + (e.message || e) + ' (' + (e.filename || '') + ':' + (e.lineno || '') + ')'); } catch(_){}
});
window.addEventListener('unhandledrejection', function(e){
  try { debugLog('[ERROR] Unhandled promise rejection: ' + (e.reason && e.reason.message ? e.reason.message : JSON.stringify(e.reason))); } catch(_){}
});

// attach click listener safely on DOMContentLoaded
document.addEventListener('DOMContentLoaded', function(){
  try{
    debugLog('[DEBUG] DOMContentLoaded fired');
    const btn = document.getElementById('openUnknownTestBtn');
    if(btn){ btn.addEventListener('click', openUnknownTestModal); debugLog('[DEBUG] attached click listener to openUnknownTestBtn'); }
    debugLog('[DEBUG] Debug panel initialized');
  }catch(err){ console.error(err); debugLog('[ERROR] DOMContentLoaded handler error: ' + err); }
});
</script>

{% endblock %}
